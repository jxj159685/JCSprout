# ReadWriteLock
1.前16位读共享右移 后16位写独占左移

2.如何获取读锁，断有没有独占锁（写锁），判断是不是当前线程，
  重入的最大次数是否超过最大值
  是否需要排队
  final boolean writerShouldBlock() {
      //是否有前置节点，有没有人等待
      return hasQueuedPredecessors();
  }
  
3.新的线程进来，先处理状态的事情，再处理队列的事情 
  如果状态值大于0，说明有线程占有这个锁，那我需要加入队列，
  同时判断一下是不是需要，让自己暂停。
  
4.锁为什么不能升级，升级了会死锁    
  t1 read -> write
  t2 read -> write 
  不允许锁升级，因为这会导致死锁，如果只有一个线程试图升级锁是没有问题的，
  可是只有一个线程毕竟是少数情况。试想如果两个线程同时尝试升级锁，两个线
  程都在等待对方释放读锁，它们之间就发生了死锁。
  在拿到写锁之前，读锁已经释放。
  
5.读锁加锁过程
  sharedCount 多少个读锁 当前只有自己加锁我是第一名
  exclusiveCount 写锁状态 直接返回
  fullTryAcquireShared    